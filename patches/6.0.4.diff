diff -urN Soft/src/data_import/biomass_convert.c ../polsarpro-6.0.4/Soft/src/data_import/biomass_convert.c
--- Soft/src/data_import/biomass_convert.c	1970-01-01 01:00:00.000000000 +0100
+++ ../polsarpro-6.0.4/Soft/src/data_import/biomass_convert.c	2025-01-08 22:39:42.000000000 +0100
@@ -0,0 +1,385 @@
+/********************************************************************
+PolSARpro v6.0.4 is free software; you can redistribute it and/or 
+modify it under the terms of the GNU General Public License as 
+published by the Free Software Foundation; either version 2 (1991) of
+the License, or any later version. This program is distributed in the
+hope that it will be useful, but WITHOUT ANY WARRANTY; without even 
+the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+PURPOSE. 
+
+See the GNU General Public License (Version 2, 1991) for more details
+
+*********************************************************************
+
+File     : biomass_convert.c
+Project  : ESA_POLSARPRO
+Authors  : Eric POTTIER
+Version  : 1.0
+Creation : 12/2024
+Update   :
+*--------------------------------------------------------------------
+INSTITUT D'ELECTRONIQUE et de TELECOMMUNICATIONS de RENNES (I.E.T.R)
+UMR CNRS 6164
+
+Waves and Signal department
+SHINE Team 
+
+
+UNIVERSITY OF RENNES I
+Bât. 11D - Campus de Beaulieu
+263 Avenue Général Leclerc
+35042 RENNES Cedex
+Tel :(+33) 2 23 23 57 63
+Fax :(+33) 2 23 23 69 63
+e-mail: eric.pottier@univ-rennes1.fr
+
+*--------------------------------------------------------------------
+
+Description :  Convert BIOMASS Binary Data Files 
+               (Format SLC)
+
+********************************************************************/
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+
+#include "omp.h"
+
+#ifdef _WIN32
+#include <dos.h>
+#include <conio.h>
+#endif
+
+/* ALIASES  */
+
+/* CONSTANTS  */
+
+/* ROUTINES DECLARATION */
+#include "../lib/PolSARproLib.h"
+
+/********************************************************************
+*********************************************************************
+*
+*            -- Function : Main
+*
+*********************************************************************
+********************************************************************/
+int main(int argc, char *argv[])
+{
+
+#define Npol 4
+#define NPolType 5
+/* LOCAL VARIABLES */
+  FILE *in_file[Npol];
+  int Config;
+  char *PolTypeConf[NPolType] = {"S2", "C3", "C4", "T3", "T4"};
+  char File11[FilePathLength],File12[FilePathLength],File21[FilePathLength],File22[FilePathLength];
+  
+/* Internal variables */
+  int ii, lig, col, k, l;
+  int indlig, indcol;
+  int SubSampLig, SubSampCol;
+  int NLookLig, NLookCol;
+ 
+  int Symmetrisation;
+  
+  float xx;
+
+  int NligBlockFinal;
+
+/* Matrix arrays */
+  float ***S_in;
+  float ***M_in;
+  float ***M_out;
+
+/********************************************************************
+********************************************************************/
+/* USAGE */
+
+strcpy(UsageHelp,"\nbiomass_convert.exe\n");
+strcat(UsageHelp,"\nParameters:\n");
+strcat(UsageHelp," (string)	-if1 	input data file: s11.bin\n");
+strcat(UsageHelp," (string)	-if2 	input data file: s12.bin\n");
+strcat(UsageHelp," (string)	-if3 	input data file: s21.bin\n");
+strcat(UsageHelp," (string)	-if4 	input data file: s22.bin\n");
+strcat(UsageHelp," (string)	-od  	output directory\n");
+strcat(UsageHelp," (string)	-odf 	output data format\n");
+strcat(UsageHelp," (int)   	-nr  	Number of Row\n");
+strcat(UsageHelp," (int)   	-nc  	Number of Col\n");
+strcat(UsageHelp," (int)   	-ofr 	Offset Row\n");
+strcat(UsageHelp," (int)   	-ofc 	Offset Col\n");
+strcat(UsageHelp," (int)   	-fnr 	Final Number of Row\n");
+strcat(UsageHelp," (int)   	-fnc 	Final Number of Col\n");
+strcat(UsageHelp," (int)   	-nlr 	Nlook Row (1 = no multi-looking)\n");
+strcat(UsageHelp," (int)   	-nlc 	Nlook Col (1 = no multi-looking)\n");
+strcat(UsageHelp," (int)   	-ssr 	Sub-sampling Row (1 = no subsampling)\n");
+strcat(UsageHelp," (int)   	-ssc 	Sub-sampling Col (1 = no subsampling)\n");
+strcat(UsageHelp," (int)   	-sym 	symmetrisation (no: 0, yes: 1)\n");
+strcat(UsageHelp,"\nOptional Parameters:\n");
+strcat(UsageHelp," (string)	-errf	memory error file\n");
+strcat(UsageHelp," (noarg) 	-help	displays this message\n");
+strcat(UsageHelp," (noarg) 	-data	displays the help concerning Data Format parameter\n");
+
+/*******************************************************************/
+
+strcpy(UsageHelpDataFormat,"\nPolarimetric Output Data Format\n");
+strcat(UsageHelpDataFormat," S2 	output : quad-pol S2\n");
+strcat(UsageHelpDataFormat,"\n");
+strcat(UsageHelpDataFormat," C3 	output : covariance C3\n");
+strcat(UsageHelpDataFormat,"\n");
+strcat(UsageHelpDataFormat," C4 	output : covariance C4\n");
+strcat(UsageHelpDataFormat,"\n");
+strcat(UsageHelpDataFormat," T3 	output : coherency T3\n");
+strcat(UsageHelpDataFormat,"\n");
+strcat(UsageHelpDataFormat," T4 	output : coherency T4\n");
+strcat(UsageHelpDataFormat,"\n");
+
+/********************************************************************
+********************************************************************/
+/* PROGRAM START */
+
+if(get_commandline_prm(argc,argv,"-help",no_cmd_prm,NULL,0,UsageHelp)) {
+  printf("\n Usage:\n%s\n",UsageHelp); exit(1);
+  }
+if(get_commandline_prm(argc,argv,"-data",no_cmd_prm,NULL,0,UsageHelpDataFormat)) {
+  printf("\n Usage:\n%s\n",UsageHelpDataFormat); exit(1);
+  }
+
+if(argc < 35) {
+  edit_error("Not enough input arguments\n Usage:\n",UsageHelp);
+  } else {
+  get_commandline_prm(argc,argv,"-if1",str_cmd_prm,File11,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-if2",str_cmd_prm,File12,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-if3",str_cmd_prm,File21,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-if4",str_cmd_prm,File22,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-od",str_cmd_prm,out_dir,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-odf",str_cmd_prm,PolType,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-nr",int_cmd_prm,&Nlig,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-nc",int_cmd_prm,&Ncol,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-ofr",int_cmd_prm,&Off_lig,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-ofc",int_cmd_prm,&Off_col,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-fnr",int_cmd_prm,&Sub_Nlig,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-fnc",int_cmd_prm,&Sub_Ncol,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-nlr",int_cmd_prm,&NLookLig,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-nlc",int_cmd_prm,&NLookCol,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-ssr",int_cmd_prm,&SubSampLig,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-ssc",int_cmd_prm,&SubSampCol,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-sym",int_cmd_prm,&Symmetrisation,1,UsageHelp);
+
+  get_commandline_prm(argc,argv,"-errf",str_cmd_prm,file_memerr,0,UsageHelp);
+
+  MemoryAlloc = -1; MemoryAlloc = CheckFreeMemory();
+  MemoryAlloc = my_max(MemoryAlloc,1000);
+
+  PSP_Threads = omp_get_max_threads();
+  if (PSP_Threads <= 2) {
+    PSP_Threads = 1;
+    } else {
+	PSP_Threads = PSP_Threads - 1;
+	}
+  omp_set_num_threads(PSP_Threads);
+
+  Config = 0;
+  for (ii=0; ii<NPolType; ii++) if (strcmp(PolTypeConf[ii],PolType) == 0) Config = 1;
+  if (Config == 0) edit_error("\nWrong argument in the Polarimetric Data Format\n",UsageHelpDataFormat);
+
+  if (NLookLig == 0) edit_error("\nWrong argument in the Nlook Row parameter\n",UsageHelp);
+  if (NLookCol == 0) edit_error("\nWrong argument in the Nlook Col parameter\n",UsageHelp);
+  if (SubSampLig == 0) edit_error("\nWrong argument in the Sub Sampling Row parameter\n",UsageHelp);
+  if (SubSampCol == 0) edit_error("\nWrong argument in the Sub Sampling Col parameter\n",UsageHelp);
+  }
+
+/********************************************************************
+********************************************************************/
+
+  check_file(File11);
+  check_file(File12);
+  check_file(File21);
+  check_file(File22);
+  check_dir(out_dir);
+
+  NwinL = 1; NwinC = 1;
+ 
+/* POLAR TYPE CONFIGURATION */
+  PolTypeConfig(PolType, &NpolarIn, PolTypeIn, &NpolarOut, PolTypeOut, PolarType);
+  NpolarIn = 4;
+  
+  file_name_out = matrix_char(NpolarOut,1024); 
+
+/* INPUT/OUTPUT FILE CONFIGURATION */
+  init_file_name(PolTypeOut, out_dir, file_name_out);
+
+/* DATA FILES */
+  if ((in_file[0] = fopen(File11, "rb")) == NULL)
+    edit_error("Could not open input file : ", File11);
+  if ((in_file[1] = fopen(File12, "rb")) == NULL)
+    edit_error("Could not open input file : ", File12);
+  if ((in_file[2] = fopen(File21, "rb")) == NULL)
+    edit_error("Could not open input file : ", File21);
+  if ((in_file[3] = fopen(File22, "rb")) == NULL)
+    edit_error("Could not open input file : ", File22);
+
+/* OUTPUT FILE OPENING*/
+  for (Np = 0; Np < NpolarOut; Np++)
+    if ((out_datafile[Np] = fopen(file_name_out[Np], "wb")) == NULL)
+      edit_error("Could not open input file : ", file_name_out[Np]);
+  
+/********************************************************************
+********************************************************************/
+/* MEMORY ALLOCATION */
+/*
+MemAlloc = NBlockA*Nlig + NBlockB
+*/ 
+
+/* Local Variables */
+
+  if (strcmp(PolTypeOut,"S2")==0) {
+    /* Mout = NpolarOut*Nlig*2*Sub_Ncol */
+    NBlockA = NpolarOut*2*Sub_Ncol; NBlockB = 0;
+    } else {
+    /* Mout = NpolarOut*Nlig*Sub_Ncol */
+    NBlockA = NpolarOut*Sub_Ncol; NBlockB = 0;
+    /* Min = NpolarOut*Nlig*Ncol */
+    NBlockA += NpolarOut*Ncol; NBlockB += 0;
+    }    
+  /* Sin = NpolarIn*Nlig*2*Ncol */
+  NBlockA += NpolarIn*2*Ncol; NBlockB += 0;
+  
+/* Reading Data */
+  NBlockB += NpolarIn*2*Ncol + NpolarOut*NwinL*(Ncol+NwinC);
+
+  memory_alloc(file_memerr, Sub_Nlig, 0, &NbBlock, NligBlock, NBlockA, NBlockB, MemoryAlloc);
+
+  if (NbBlock != 1) block_alloc(NligBlock, SubSampLig, NLookLig, Sub_Nlig, &NbBlock);
+
+/********************************************************************
+********************************************************************/
+/* MATRIX ALLOCATION */
+
+  S_in = matrix3d_float(NpolarIn, NligBlock[0], 2*Ncol);
+  if (strcmp(PolTypeOut,"S2")==0) {
+    M_out = matrix3d_float(NpolarOut, NligBlock[0], 2*Sub_Ncol);
+    } else {
+    M_in = matrix3d_float(NpolarOut, NligBlock[0], Ncol);
+    M_out = matrix3d_float(NpolarOut, NligBlock[0], Sub_Ncol);
+    }    
+  
+/********************************************************************
+********************************************************************/
+/* DATA PROCESSING */
+
+  Sub_Nlig = (int) floor((Sub_Nlig / SubSampLig) / NLookLig);
+  Sub_Ncol = (int) floor((Sub_Ncol / SubSampCol) / NLookCol);
+
+/* Offset Lines Reading */
+  for (lig = 0; lig < Off_lig; lig++)
+    for (Np = 0; Np < Npol; Np++) 
+      fread(&S_in[Np][0][0], sizeof(float), 2 * Ncol, in_file[Np]);
+  
+for (Nb = 0; Nb < NbBlock; Nb++) {
+
+  if (NbBlock > 2) {printf("%f\r", 100. * Nb / (NbBlock - 1));fflush(stdout);}
+
+  for (lig = 0; lig < NligBlock[Nb]; lig++) {
+    PrintfLine(lig,NligBlock[Nb]);
+    for (Np = 0; Np < Npol; Np++)
+      fread(&S_in[Np][lig][0], sizeof(float), 2 * Ncol, in_file[Np]);
+    for (col = 0; col < Ncol; col++) {
+      for (Np = 0; Np < Npol; Np++) {
+        if (my_isfinite(S_in[Np][lig][2*col]) == 0) S_in[Np][lig][2*col] = eps;
+        if (my_isfinite(S_in[Np][lig][2*col + 1]) == 0) S_in[Np][lig][2*col + 1] = eps;
+        }
+      }
+    }
+
+  if (strcmp(PolTypeOut,"S2")==0) {
+    /* Symmetrisation */
+    if (Symmetrisation == 1) {
+      for (lig = 0; lig < NligBlock[Nb]; lig++) {
+        PrintfLine(lig,NligBlock[Nb]);
+        for (col = 0; col < Ncol; col++) {
+          xx = (S_in[s12][lig][2*col]+S_in[s21][lig][2*col])/2.;
+          S_in[s12][lig][2*col] = xx; S_in[s21][lig][2*col] = xx;
+          xx = (S_in[s12][lig][2*col+1]+S_in[s21][lig][2*col+1])/2.;
+          S_in[s12][lig][2*col+1] = xx; S_in[s21][lig][2*col+1] = xx;
+          }
+        }
+      }
+    NligBlockFinal = (int) floor(NligBlock[Nb]/ (SubSampLig));
+    for (lig = 0; lig < NligBlockFinal; lig++) {
+      if (NbBlock <= 2) PrintfLine(lig,NligBlockFinal);
+      indlig = lig * SubSampLig;
+      for (col = 0; col < Sub_Ncol; col++) {
+        indcol = col * SubSampCol;
+        for (Np = 0; Np < NpolarOut; Np++) {
+          M_out[Np][lig][2*col] = S_in[Np][indlig][2*(indcol+Off_col)];
+          M_out[Np][lig][2*col+1] = S_in[Np][indlig][2*(indcol+Off_col)+1];
+          }
+        }
+      }
+
+    write_block_matrix3d_cmplx(out_datafile, NpolarOut, M_out, NligBlockFinal, Sub_Ncol, 0, 0, Sub_Ncol);
+
+    if (Symmetrisation == 1) strcpy(PolarCase, "monostatic");
+    if (Symmetrisation == 0) strcpy(PolarCase, "bistatic");
+      
+    } else {
+
+    if (strcmp(PolTypeOut,"C3")==0) S2_to_C3(S_in, M_in, NligBlock[Nb], Ncol, 0, 0);
+    if (strcmp(PolTypeOut,"T3")==0) S2_to_T3(S_in, M_in, NligBlock[Nb], Ncol, 0, 0);
+    if (strcmp(PolTypeOut,"C4")==0) S2_to_C4(S_in, M_in, NligBlock[Nb], Ncol, 0, 0);
+    if (strcmp(PolTypeOut,"T4")==0) S2_to_T4(S_in, M_in, NligBlock[Nb], Ncol, 0, 0);
+
+    NligBlockFinal = (int) floor(NligBlock[Nb]/ (SubSampLig*NLookLig));
+    for (lig = 0; lig < NligBlockFinal; lig++) {
+      if (NbBlock <= 2) PrintfLine(lig,NligBlockFinal);
+      indlig = lig * SubSampLig * NLookLig;
+      for (col = 0; col < Sub_Ncol; col++) {
+        indcol = col * SubSampCol * NLookCol;
+        for (Np = 0; Np < NpolarOut; Np++) {
+          M_out[Np][lig][col] = 0.;
+          for (k = 0; k < NLookLig; k++)
+            for (l = 0; l < NLookCol; l++)
+              M_out[Np][lig][col] += M_in[Np][indlig+k][indcol+l+Off_col];
+          M_out[Np][lig][col] /= (NLookLig*NLookCol);
+          }
+        }
+      }
+      
+    write_block_matrix3d_float(out_datafile, NpolarOut, M_out, NligBlockFinal, Sub_Ncol, 0, 0, Sub_Ncol);
+
+    if (strcmp(PolTypeOut,"C3")==0) strcpy(PolarCase, "monostatic");
+    if (strcmp(PolTypeOut,"C4")==0) strcpy(PolarCase, "bistatic");
+    if (strcmp(PolTypeOut,"T3")==0) strcpy(PolarCase, "monostatic");
+    if (strcmp(PolTypeOut,"T4")==0) strcpy(PolarCase, "bistatic");
+    }
+  
+  } // NbBlock
+
+/* OUPUT CONFIGURATIONS */
+  strcpy(PolarType, "full");
+  write_config(out_dir, Sub_Nlig, Sub_Ncol, PolarCase, PolarType);
+
+/********************************************************************
+********************************************************************/
+/* MATRIX FREE-ALLOCATION */
+
+  free_matrix3d_float(S_in, NpolarIn, NligBlock[0]);
+  if (strcmp(PolTypeOut,"S2")!=0) free_matrix3d_float(M_in, NpolarOut, NligBlock[0]);
+  free_matrix3d_float(M_out, NpolarOut, NligBlock[0]);
+  
+/********************************************************************
+********************************************************************/
+
+/* OUTPUT FILE CLOSING*/
+  for (Np = 0; Np < NpolarOut; Np++) fclose(out_datafile[Np]);
+  for (Np = 0; Np < Npol; Np++) fclose(in_file[Np]);
+  
+/********************************************************************
+********************************************************************/
+
+  return 1;
+}
+
+
diff -urN Soft/src/data_import/biomass_google.c ../polsarpro-6.0.4/Soft/src/data_import/biomass_google.c
--- Soft/src/data_import/biomass_google.c	1970-01-01 01:00:00.000000000 +0100
+++ ../polsarpro-6.0.4/Soft/src/data_import/biomass_google.c	2025-01-08 22:39:42.000000000 +0100
@@ -0,0 +1,191 @@
+/********************************************************************
+PolSARpro v6.0.4 is free software; you can redistribute it and/or 
+modify it under the terms of the GNU General Public License as 
+published by the Free Software Foundation; either version 2 (1991) of
+the License, or any later version. This program is distributed in the
+hope that it will be useful, but WITHOUT ANY WARRANTY; without even 
+the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+PURPOSE. 
+
+See the GNU General Public License (Version 2, 1991) for more details
+
+*********************************************************************
+
+File     : biomass_google.c
+Project  : ESA_POLSARPRO
+Authors  : Eric POTTIER
+Version  : 1.0
+Creation : 06/2024
+Update   : 
+*--------------------------------------------------------------------
+INSTITUT D'ELECTRONIQUE et de TELECOMMUNICATIONS de RENNES (I.E.T.R)
+UMR CNRS 6164
+
+Waves and Signal department
+SHINE Team 
+
+
+UNIVERSITY OF RENNES I
+Bât. 11D - Campus de Beaulieu
+263 Avenue Général Leclerc
+35042 RENNES Cedex
+Tel :(+33) 2 23 23 57 63
+Fax :(+33) 2 23 23 69 63
+e-mail: eric.pottier@univ-rennes1.fr
+
+*--------------------------------------------------------------------
+
+Description :  Create a Google Kml File
+
+********************************************************************/
+/* C INCLUDES */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+
+#include "omp.h"
+
+#ifdef _WIN32
+#include <dos.h>
+#include <conio.h>
+#endif
+
+/* ROUTINES DECLARATION */
+#include "../lib/PolSARproLib.h"
+
+/* ACCESS FILE */
+FILE *filename;
+
+/********************************************************************
+*********************************************************************
+*
+*            -- Function : Main
+*
+*********************************************************************
+********************************************************************/
+
+int main(int argc, char *argv[])
+/*                                      */
+{
+
+/* LOCAL VARIABLES */
+
+  char DirInput[FilePathLength];
+  char FileName[FilePathLength];
+  char FileGoogle[FilePathLength];
+  char FileTmp[FilePathLength];
+
+  char Tmp[100];
+  float Lat00,LatN0,Lat0N,LatNN;
+  float Lon00,LonN0,Lon0N,LonNN;
+  float LatCenter, LonCenter;
+
+/********************************************************************
+********************************************************************/
+/* USAGE */
+
+strcpy(UsageHelp,"\nbiomass_google.exe\n");
+strcat(UsageHelp,"\nParameters:\n");
+strcat(UsageHelp," (string)	-id  	input directory\n");
+strcat(UsageHelp," (string)	-if  	input header file\n");
+strcat(UsageHelp," (string)	-of  	output google file\n");
+strcat(UsageHelp,"\nOptional Parameters:\n");
+strcat(UsageHelp," (noarg) 	-help	displays this message\n");
+
+/********************************************************************
+********************************************************************/
+/* PROGRAM START */
+
+if(get_commandline_prm(argc,argv,"-help",no_cmd_prm,NULL,0,UsageHelp)) {
+  printf("\n Usage:\n%s\n",UsageHelp); exit(1);
+  }
+
+if(argc < 7) {
+  edit_error("Not enough input arguments\n Usage:\n",UsageHelp);
+  } else {
+  get_commandline_prm(argc,argv,"-id",str_cmd_prm,DirInput,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-if",str_cmd_prm,FileTmp,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-of",str_cmd_prm,FileGoogle,1,UsageHelp);
+  }
+
+/********************************************************************
+********************************************************************/
+
+  check_dir(DirInput);
+  check_file(FileGoogle);
+  check_file(FileTmp);
+
+  PSP_Threads = omp_get_max_threads();
+  if (PSP_Threads <= 2) {
+    PSP_Threads = 1;
+    } else {
+	PSP_Threads = PSP_Threads - 1;
+	}
+  omp_set_num_threads(PSP_Threads);
+
+/*******************************************************************/
+/* INPUT FILE */
+/*******************************************************************/
+
+  if ((filename = fopen(FileTmp, "r")) == NULL)
+    edit_error("Could not open output file : ", FileTmp);
+  rewind(filename);
+  fscanf(filename, "%s\n", Tmp);
+  fscanf(filename, "%s\n", Tmp);
+  fscanf(filename, "%s\n", Tmp);
+  fscanf(filename, "%f %f %f %f %f %f %f %f %f %f\n", &Lat00, &Lon00, &Lat0N, &Lon0N, &LatNN, &LonNN, &LatN0, &LonN0, &Lat00, &Lon00);
+  fscanf(filename, "%f %f\n", &LatCenter, &LonCenter);
+  fclose(filename);
+
+/*******************************************************************/
+/* WRITE GOOGLE FILE */
+/*******************************************************************/
+
+  sprintf(FileName, "%s%s", DirInput, "GEARTH_POLY.kml");
+  if ((filename = fopen(FileName, "w")) == NULL)
+    edit_error("Could not open output file : ", FileName);
+
+  fprintf(filename,"<!-- ?xml version=\"1.0\" encoding=\"UTF-8\"? -->\n");
+  fprintf(filename,"<kml xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n");
+  fprintf(filename,"<Placemark>\n");
+  fprintf(filename,"<name>\n");
+  fprintf(filename, "Image BIOMASS\n");
+  fprintf(filename,"</name>\n");
+  fprintf(filename,"<Style>\n");
+  fprintf(filename,"<LineStyle>\n");
+  fprintf(filename,"<color>ff0000ff</color>\n");
+  fprintf(filename,"<width>4</width>\n");
+  fprintf(filename,"</LineStyle>\n");
+  fprintf(filename,"</Style>\n");
+  fprintf(filename,"<LineString>\n");
+  fprintf(filename,"<coordinates>\n");
+  fprintf(filename, "%f,%f,8000.0\n", Lon00,Lat00);
+  fprintf(filename, "%f,%f,8000.0\n", LonN0,LatN0);
+  fprintf(filename, "%f,%f,8000.0\n", LonNN,LatNN);
+  fprintf(filename, "%f,%f,8000.0\n", Lon0N,Lat0N);
+  fprintf(filename, "%f,%f,8000.0\n", Lon00,Lat00);
+  fprintf(filename,"</coordinates>\n");
+  fprintf(filename,"</LineString>\n");
+  fprintf(filename,"</Placemark>\n");
+  fprintf(filename,"</kml>\n");
+
+  fclose(filename);
+
+  if ((filename = fopen(FileGoogle, "w")) == NULL)
+    edit_error("Could not open output file : ", FileGoogle);
+  fprintf(filename, "%f\n", LatCenter);
+  fprintf(filename, "%f\n", LonCenter);
+  fprintf(filename, "%f\n", Lat00);
+  fprintf(filename, "%f\n", Lon00);
+  fprintf(filename, "%f\n", Lat0N);
+  fprintf(filename, "%f\n", Lon0N);
+  fprintf(filename, "%f\n", LatN0);
+  fprintf(filename, "%f\n", LonN0);
+  fprintf(filename, "%f\n", LatNN);
+  fprintf(filename, "%f\n", LonNN);
+  fclose(filename);
+
+  return 1;
+}
+
diff -urN Soft/src/data_process_sngl/arii_anned_3components_decomposition.c ../polsarpro-6.0.4/Soft/src/data_process_sngl/arii_anned_3components_decomposition.c
--- Soft/src/data_process_sngl/arii_anned_3components_decomposition.c	2025-04-23 11:11:20.302846569 +0200
+++ ../polsarpro-6.0.4/Soft/src/data_process_sngl/arii_anned_3components_decomposition.c	2025-01-08 22:39:54.000000000 +0100
@@ -86,11 +86,10 @@
   float hh1_re, hh1_im, vv1_re, vv1_im, hh2_re, hh2_im;
   float A0A0, B0pB;
   float sig, phi, psig, qsig;
-  float xopt, xmin, xmax, xprevious, xx;
+  float xopt, xmin, xmax, xprevious, xx, xxx;
   float test, previous, Pmin;
  
   float amax, a11, a22, a33;
-  float a12, a13, a23, b, c, d;
 
 /* Matrix arrays */
   float ***M_in;
@@ -372,9 +371,9 @@
 ALPre = ALPim = BETre = BETim = OMEGA1 = OMEGA2 = OMEGAodd = OMEGAdbl = 0.;
 delta = lambda1 = lambda2 = gamma = epsilon = rho_re = rho_im = 0.;
 hh1_re = hh1_im = vv1_re = vv1_im = hh2_re = hh2_im = A0A0 = B0pB = 0.;
-sig = phi = psig = qsig = xopt = xmin = xmax = xprevious = xx = test = previous = Pmin = 0.;
-amax = a11 = a22 = a33 = a12 = a13 = a23 = b = c = d = 0.;
-#pragma omp parallel for private(col, ii, jj, M_avg, M, V, lambda) firstprivate(iiopt, jjopt, flagstop, ALPre, ALPim, BETre, BETim, OMEGA1, OMEGA2, OMEGAodd, OMEGAdbl, delta, lambda1, lambda2, gamma, epsilon, rho_re, rho_im, hh1_re, hh1_im, vv1_re, vv1_im, hh2_re, hh2_im, A0A0, B0pB, sig, phi, psig, qsig, xopt, xmin, xmax, xprevious, xx, test, previous, Pmin, amax, a11, a22, a33, a12, a13, a23, b, c, d) shared(ligDone)
+sig = phi = psig = qsig = xopt = xmin = xmax = xprevious = xx = xxx = test = previous = Pmin = 0.;
+amax = a11 = a22 = a33 = 0.;
+#pragma omp parallel for private(col, ii, jj, M_avg, M, V, lambda) firstprivate(iiopt, jjopt, flagstop, ALPre, ALPim, BETre, BETim, OMEGA1, OMEGA2, OMEGAodd, OMEGAdbl, delta, lambda1, lambda2, gamma, epsilon, rho_re, rho_im, hh1_re, hh1_im, vv1_re, vv1_im, hh2_re, hh2_im, A0A0, B0pB, sig, phi, psig, qsig, xopt, xmin, xmax, xprevious, xx, xxx, test, previous, Pmin, amax, a11, a22, a33) shared(ligDone)
   for (lig = 0; lig < NligBlock[Nb]; lig++) {
     ligDone++;
     if (omp_get_thread_num() == 0) PrintfLine(ligDone,NligBlock[Nb]);
@@ -392,29 +391,10 @@
             a11 = M_avg[C311][col]/CV[ii][jj][C311];
             a22 = M_avg[C322][col]/CV[ii][jj][C322];
             a33 = M_avg[C333][col]/CV[ii][jj][C333];
-            //a12
-            b = M_avg[C311][col]*CV[ii][jj][C322]+M_avg[C322][col]*CV[ii][jj][C311];
-            b = b - 2.*(M_avg[C312_re][col]*CV[ii][jj][C312_re]+M_avg[C312_im][col]*CV[ii][jj][C312_im]);
-            c = M_avg[C311][col]*M_avg[C322][col]-M_avg[C312_re][col]*M_avg[C312_re][col]-M_avg[C312_im][col]*M_avg[C312_im][col];
-            d = CV[ii][jj][C311]*CV[ii][jj][C322]-CV[ii][jj][C312_re]*CV[ii][jj][C312_re]-CV[ii][jj][C312_im]*CV[ii][jj][C312_im];
-            a12 = (b-sqrt(b*b-4.*c*d))/(2.*d);
-            //a13
-            b = M_avg[C311][col]*CV[ii][jj][C333]+M_avg[C333][col]*CV[ii][jj][C311];
-            b = b - 2.*(M_avg[C313_re][col]*CV[ii][jj][C313_re]+M_avg[C313_im][col]*CV[ii][jj][C313_im]);
-            c = M_avg[C311][col]*M_avg[C333][col]-M_avg[C313_re][col]*M_avg[C313_re][col]-M_avg[C313_im][col]*M_avg[C313_im][col];
-            d = CV[ii][jj][C311]*CV[ii][jj][C333]-CV[ii][jj][C313_re]*CV[ii][jj][C313_re]-CV[ii][jj][C313_im]*CV[ii][jj][C313_im];
-            a13 = (b-sqrt(b*b-4.*c*d))/(2.*d);
-            //a23
-            b = M_avg[C322][col]*CV[ii][jj][C333]+M_avg[C333][col]*CV[ii][jj][C322];
-            b = b - 2.*(M_avg[C323_re][col]*CV[ii][jj][C323_re]+M_avg[C323_im][col]*CV[ii][jj][C323_im]);
-            c = M_avg[C322][col]*M_avg[C333][col]-M_avg[C323_re][col]*M_avg[C323_re][col]-M_avg[C323_im][col]*M_avg[C323_im][col];
-            d = CV[ii][jj][C322]*CV[ii][jj][C333]-CV[ii][jj][C323_re]*CV[ii][jj][C323_re]-CV[ii][jj][C323_im]*CV[ii][jj][C323_im];
-            a23 = (b-sqrt(b*b-4.*c*d))/(2.*d);
 
             xmin = 0.; 
             xmax = a11; if (a22 <= xmax) xmax = a22; if (a33 <= xmax) xmax = a33;
             amax = xmax;
-            if (a12 <= xmax) xmax = a12; if (a13 <= xmax) xmax = a13; if (a23 <= xmax) xmax = a23;
             flagstop = 0; xprevious = 0.; test = 0.; previous = 0.;
 
             while (flagstop == 0) {
@@ -440,33 +420,39 @@
               M[2][2][0] = eps + M_avg[8][col] - xx*CV[ii][jj][8];
               M[2][2][1] = 0.;
 
-              a11 = M[0][0][0]*M[1][1][0]*M[2][2][0] + 2.*M[0][2][0]*(M[0][1][0]*M[1][2][0]-M[0][1][1]*M[1][2][1]);
-              a11 = a11 + 2.*M[0][2][1]*(M[0][1][1]*M[1][2][0]+M[0][1][0]*M[1][2][1]);
-              a11 = a11 - M[0][0][0]*(M[1][2][0]*M[1][2][0]+M[1][2][1]*M[1][2][1]);
-              a11 = a11 - M[1][1][0]*(M[0][2][0]*M[0][2][0]+M[0][2][1]*M[0][2][1]);
-              a11 = a11 - M[2][2][0]*(M[0][1][0]*M[0][1][0]+M[0][1][1]*M[0][1][1]);
-
-              a22 = M[0][0][0]*M[1][1][0]-(M[0][1][0]*M[0][1][0]+M[0][1][1]*M[0][1][1]);
-              a22 = a22 + M[0][0][0]*M[2][2][0]-(M[0][2][0]*M[0][2][0]+M[0][2][1]*M[0][2][1]);
-              a22 = a22 + M[1][1][0]*M[2][2][0]-(M[1][2][0]*M[1][2][0]+M[1][2][1]*M[1][2][1]);
-
-              a33 = M[0][0][0] + M[1][1][0] + M[2][2][0];
-
               test = -1;
-              if ((a11 > 0.)&&(a22 > 0.)&&(a33 > 0.)) test = +1.;
-              
+              Diagonalisation(3, M, V, lambda);
+              if ((lambda[0] > 0.)&&(lambda[1] > 0.)&&(lambda[2] > 0.)) test = +1.;
+
               if (test == -1.) {
-                xmax = xx; xmin = xmin;
+                if (previous != +1.) {
+                  xmax = xx; xmin = xmin; xprevious = xx;
+                  xxx = (xmax - xmin)/2.;
+                  if (fabs(xxx - xprevious) < (amax / 100.)) {
+                    flagstop = 1;
+                    xx = xprevious;
+                    }
+                  }
+                if (previous == +1.) {
+                  flagstop = 1;
+                  xx = xprevious;
+                  }
                 previous = -1.;
-                } else {
+                }
+
+              if (test == +1.) {
                 xmax = xmax; xmin = xx; xprevious = xx;
-                if (previous == +1.) {
-                  xx = (xmax - xmin)/2.;
-                  if (fabs(xx - xprevious) < (amax / 100.)) {
+                if (previous != -1.) {
+                  xxx = (xmax - xmin)/2.;
+                  if (fabs(xxx - xprevious) < (amax / 100.)) {
                     flagstop = 1;
                     xx = xprevious;
                     }
                   }
+                if (previous == -1.) {
+                  flagstop = 1;
+                  xx = xprevious;
+                  }
                 previous = +1.;                
                 }
               }
diff -urN Soft/src/data_process_sngl/dey_bhattacharya_frery_lopez_rao_4components_decomposition_FP.c ../polsarpro-6.0.4/Soft/src/data_process_sngl/dey_bhattacharya_frery_lopez_rao_4components_decomposition_FP.c
--- Soft/src/data_process_sngl/dey_bhattacharya_frery_lopez_rao_4components_decomposition_FP.c	1970-01-01 01:00:00.000000000 +0100
+++ ../polsarpro-6.0.4/Soft/src/data_process_sngl/dey_bhattacharya_frery_lopez_rao_4components_decomposition_FP.c	2025-01-08 22:39:54.000000000 +0100
@@ -0,0 +1,481 @@
+/********************************************************************
+PolSARpro v6.0.4 is free software; you can redistribute it and/or 
+modify it under the terms of the GNU General Public License as 
+published by the Free Software Foundation; either version 2 (1991) of
+the License, or any later version. This program is distributed in the
+hope that it will be useful, but WITHOUT ANY WARRANTY; without even 
+the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+PURPOSE. 
+
+See the GNU General Public License (Version 2, 1991) for more details
+
+*********************************************************************
+
+File     : dey_bhattacharya_frery_lopez_rao_4components_decomposition_FP.c
+Project  : ESA_POLSARPRO
+Authors  : Eric POTTIER
+Version  : 1.0
+Creation : 08/2021
+Update   :
+*--------------------------------------------------------------------
+INSTITUT D'ELECTRONIQUE et de TELECOMMUNICATIONS de RENNES (I.E.T.R)
+UMR CNRS 6164
+
+Waves and Signal department
+SHINE Team 
+
+UNIVERSITY OF RENNES I
+Bât. 11D - Campus de Beaulieu
+263 Avenue Général Leclerc
+35042 RENNES Cedex
+Tel :(+33) 2 23 23 57 63
+Fax :(+33) 2 23 23 69 63
+e-mail: eric.pottier@univ-rennes1.fr
+
+*--------------------------------------------------------------------
+
+Description :  S Dey & al. - 4 Components Decomposition
+
+A Model-free Four Component Scattering Power Decomposition for 
+Polarimetric SAR Data.
+Dey S, Bhattacharya A, Frery A, López-Martínez C
+IEEE JSTARS, vol 14, 2021
+
+Target Characterization and Scattering Power Decomposition for Full
+and Compact Polarimetric SAR Data
+Dey S, Bhattacharya A, Ratha D, Mandal D, Frery A
+
+*--------------------------------------------------------------------
+
+Adapted from c routine "MF4CF.c"
+written by : Ash Richardson 
+Senior Data Scientist, BC Wildfire Service, Canada 
+2021/04/21 
+
+********************************************************************/
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+
+#include "omp.h"
+
+#ifdef _WIN32
+#include <dos.h>
+#include <conio.h>
+#endif
+
+/* ROUTINES DECLARATION */
+#include "../lib/PolSARproLib.h"
+
+/********************************************************************
+*********************************************************************
+*
+*            -- Function : Main
+*
+*********************************************************************
+********************************************************************/
+int main(int argc, char *argv[])
+{
+
+#define NPolType 3
+/* LOCAL VARIABLES */
+  FILE *out_odd, *out_dbl, *out_vol, *out_hlx;
+  FILE *out_theta, *out_tau;
+  int Config;
+  char *PolTypeConf[NPolType] = {"S2", "C3", "T3"};
+  char file_name[FilePathLength];
+  
+/* Internal variables */
+  int ii, lig, col;
+  int ligDone = 0;
+
+  float Span, SpanMin, SpanMax;
+  float Ps, Pd, Pv, Pc;
+  float theta, tau;
+  double det_re, det_im, trace, trace3, m1_re, m1_im, m1, r;
+  double k44, k11, k14, s0, dop, val1, val2, res_pow;
+
+/* Matrix arrays */
+  float ***M_in;
+  float **M_avg;
+  float **M_odd;
+  float **M_dbl;
+  float **M_vol;
+  float **M_hlx;
+  float **M_theta;
+  float **M_tau;
+  float *TT;
+
+/********************************************************************
+********************************************************************/
+/* USAGE */
+
+strcpy(UsageHelp,"\ndey_bhattacharya_frery_lopez_rao_4components_decomposition_FP.exe\n");
+strcat(UsageHelp,"\nParameters:\n");
+strcat(UsageHelp," (string)	-id  	input directory\n");
+strcat(UsageHelp," (string)	-od  	output directory\n");
+strcat(UsageHelp," (string)	-iodf	input-output data format\n");
+strcat(UsageHelp," (int)   	-nwr 	Nwin Row\n");
+strcat(UsageHelp," (int)   	-nwc 	Nwin Col\n");
+strcat(UsageHelp," (int)   	-ofr 	Offset Row\n");
+strcat(UsageHelp," (int)   	-ofc 	Offset Col\n");
+strcat(UsageHelp," (int)   	-fnr 	Final Number of Row\n");
+strcat(UsageHelp," (int)   	-fnc 	Final Number of Col\n");
+strcat(UsageHelp,"\nOptional Parameters:\n");
+strcat(UsageHelp," (string)	-mask	mask file (valid pixels)\n");
+strcat(UsageHelp," (string)	-errf	memory error file\n");
+strcat(UsageHelp," (noarg) 	-help	displays this message\n");
+strcat(UsageHelp," (noarg) 	-data	displays the help concerning Data Format parameter\n");
+
+/********************************************************************
+********************************************************************/
+
+strcpy(UsageHelpDataFormat,"\nPolarimetric Input-Output Data Format\n\n");
+for (ii=0; ii<NPolType; ii++) CreateUsageHelpDataFormatInput(PolTypeConf[ii]); 
+strcat(UsageHelpDataFormat,"\n");
+
+/********************************************************************
+********************************************************************/
+/* PROGRAM START */
+
+if(get_commandline_prm(argc,argv,"-help",no_cmd_prm,NULL,0,UsageHelp)) {
+  printf("\n Usage:\n%s\n",UsageHelp); exit(1);
+  }
+if(get_commandline_prm(argc,argv,"-data",no_cmd_prm,NULL,0,UsageHelpDataFormat)) {
+  printf("\n Usage:\n%s\n",UsageHelpDataFormat); exit(1);
+  }
+
+if(argc < 19) {
+  edit_error("Not enough input arguments\n Usage:\n",UsageHelp);
+  } else {
+  get_commandline_prm(argc,argv,"-id",str_cmd_prm,in_dir,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-od",str_cmd_prm,out_dir,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-iodf",str_cmd_prm,PolType,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-nwr",int_cmd_prm,&NwinL,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-nwc",int_cmd_prm,&NwinC,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-ofr",int_cmd_prm,&Off_lig,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-ofc",int_cmd_prm,&Off_col,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-fnr",int_cmd_prm,&Sub_Nlig,1,UsageHelp);
+  get_commandline_prm(argc,argv,"-fnc",int_cmd_prm,&Sub_Ncol,1,UsageHelp);
+
+  get_commandline_prm(argc,argv,"-errf",str_cmd_prm,file_memerr,0,UsageHelp);
+
+  MemoryAlloc = -1; MemoryAlloc = CheckFreeMemory();
+  MemoryAlloc = my_max(MemoryAlloc,1000);
+
+  PSP_Threads = omp_get_max_threads();
+  if (PSP_Threads <= 2) {
+    PSP_Threads = 1;
+    } else {
+	PSP_Threads = PSP_Threads - 1;
+	}
+  omp_set_num_threads(PSP_Threads);
+
+  FlagValid = 0;strcpy(file_valid,"");
+  get_commandline_prm(argc,argv,"-mask",str_cmd_prm,file_valid,0,UsageHelp);
+  if (strcmp(file_valid,"") != 0) FlagValid = 1;
+
+  Config = 0;
+  for (ii=0; ii<NPolType; ii++) if (strcmp(PolTypeConf[ii],PolType) == 0) Config = 1;
+  if (Config == 0) edit_error("\nWrong argument in the Polarimetric Data Format\n",UsageHelpDataFormat);
+  }
+
+  if (strcmp(PolType,"S2")==0) strcpy(PolType,"S2T3");
+
+/********************************************************************
+********************************************************************/
+
+  check_dir(in_dir);
+  check_dir(out_dir);
+  if (FlagValid == 1) check_file(file_valid);
+
+  NwinLM1S2 = (NwinL - 1) / 2;
+  NwinCM1S2 = (NwinC - 1) / 2;
+
+/* INPUT/OUPUT CONFIGURATIONS */
+  read_config(in_dir, &Nlig, &Ncol, PolarCase, PolarType);
+  
+/* POLAR TYPE CONFIGURATION */
+  PolTypeConfig(PolType, &NpolarIn, PolTypeIn, &NpolarOut, PolTypeOut, PolarType);
+  
+  file_name_in = matrix_char(NpolarIn,1024); 
+
+/* INPUT/OUTPUT FILE CONFIGURATION */
+  init_file_name(PolTypeIn, in_dir, file_name_in);
+
+/* INPUT FILE OPENING*/
+  for (Np = 0; Np < NpolarIn; Np++)
+  if ((in_datafile[Np] = fopen(file_name_in[Np], "rb")) == NULL)
+    edit_error("Could not open input file : ", file_name_in[Np]);
+
+  if (FlagValid == 1) 
+    if ((in_valid = fopen(file_valid, "rb")) == NULL)
+      edit_error("Could not open input file : ", file_valid);
+
+/* OUTPUT FILE OPENING*/
+  sprintf(file_name, "%sDey_FP_Odd.bin", out_dir);
+  if ((out_odd = fopen(file_name, "wb")) == NULL)
+    edit_error("Could not open input file : ", file_name);
+
+  sprintf(file_name, "%sDey_FP_Dbl.bin", out_dir);
+  if ((out_dbl = fopen(file_name, "wb")) == NULL)
+    edit_error("Could not open input file : ", file_name);
+
+  sprintf(file_name, "%sDey_FP_Vol.bin", out_dir);
+  if ((out_vol = fopen(file_name, "wb")) == NULL)
+    edit_error("Could not open input file : ", file_name);
+  
+  sprintf(file_name, "%sDey_FP_Hlx.bin", out_dir);
+  if ((out_hlx = fopen(file_name, "wb")) == NULL)
+    edit_error("Could not open input file : ", file_name);
+  
+  sprintf(file_name, "%sDey_FP_Theta.bin", out_dir);
+  if ((out_theta = fopen(file_name, "wb")) == NULL)
+    edit_error("Could not open input file : ", file_name);
+  
+  sprintf(file_name, "%sDey_FP_Tau.bin", out_dir);
+  if ((out_tau = fopen(file_name, "wb")) == NULL)
+    edit_error("Could not open input file : ", file_name);
+  
+/********************************************************************
+********************************************************************/
+/* MEMORY ALLOCATION */
+/*
+MemAlloc = NBlockA*Nlig + NBlockB
+*/ 
+
+/* Local Variables */
+  NBlockA = 0; NBlockB = 0;
+  /* Mask */ 
+  NBlockA += Sub_Ncol+NwinC; NBlockB += NwinL*(Sub_Ncol+NwinC);
+
+  /* Modd = Nlig*Sub_Ncol */
+  NBlockA += Sub_Ncol; NBlockB += 0;
+  /* Mdbl = Nlig*Sub_Ncol */
+  NBlockA += Sub_Ncol; NBlockB += 0;
+  /* Mvol = Nlig*Sub_Ncol */
+  NBlockA += Sub_Ncol; NBlockB += 0;
+  /* Mhlx = Nlig*Sub_Ncol */
+  NBlockA += Sub_Ncol; NBlockB = 0;
+  /* Mtheta = Nlig*Sub_Ncol */
+  NBlockA += Sub_Ncol; NBlockB = 0;
+  /* Mtau = Nlig*Sub_Ncol */
+  NBlockA += Sub_Ncol; NBlockB = 0;
+  /* Min = NpolarOut*Nlig*Sub_Ncol */
+  NBlockA += NpolarOut*(Ncol+NwinC); NBlockB += NpolarOut*NwinL*(Ncol+NwinC);
+  /* Mavg = NpolarOut */
+  NBlockA += 0; NBlockB += NpolarOut*Sub_Ncol;
+  
+/* Reading Data */
+  NBlockB += Ncol + 2*Ncol + NpolarIn*2*Ncol + NpolarOut*NwinL*(Ncol+NwinC);
+
+  memory_alloc(file_memerr, Sub_Nlig, NwinL, &NbBlock, NligBlock, NBlockA, NBlockB, MemoryAlloc);
+
+/********************************************************************
+********************************************************************/
+/* MATRIX ALLOCATION */
+
+  _VC_in = vector_float(2*Ncol);
+  _VF_in = vector_float(Ncol);
+  _MC_in = matrix_float(4,2*Ncol);
+  _MF_in = matrix3d_float(NpolarOut,NwinL, Ncol+NwinC);
+
+/*-----------------------------------------------------------------*/   
+
+  Valid = matrix_float(NligBlock[0] + NwinL, Sub_Ncol + NwinC);
+
+  M_in = matrix3d_float(NpolarOut, NligBlock[0] + NwinL, Ncol + NwinC);
+  //M_avg = matrix_float(NpolarOut, Sub_Ncol);
+  M_odd = matrix_float(NligBlock[0], Sub_Ncol);
+  M_dbl = matrix_float(NligBlock[0], Sub_Ncol);
+  M_vol = matrix_float(NligBlock[0], Sub_Ncol);
+  M_hlx = matrix_float(NligBlock[0], Sub_Ncol);
+  M_theta = matrix_float(NligBlock[0], Sub_Ncol);
+  M_tau = matrix_float(NligBlock[0], Sub_Ncol);
+
+/********************************************************************
+********************************************************************/
+/* MASK VALID PIXELS (if there is no MaskFile */
+  if (FlagValid == 0) 
+#pragma omp parallel for private(col)
+    for (lig = 0; lig < NligBlock[0] + NwinL; lig++) 
+      for (col = 0; col < Sub_Ncol + NwinC; col++) 
+        Valid[lig][col] = 1.;
+ 
+/********************************************************************
+********************************************************************/
+/* SPANMIN / SPANMAX DETERMINATION */
+for (Np = 0; Np < NpolarIn; Np++) rewind(in_datafile[Np]);
+if (FlagValid == 1) rewind(in_valid);
+
+Span = 0.;
+SpanMin = INIT_MINMAX;
+SpanMax = -INIT_MINMAX;
+  
+for (Nb = 0; Nb < NbBlock; Nb++) {
+  ligDone = 0;
+  if (NbBlock > 2) {printf("%f\r", 100. * Nb / (NbBlock - 1));fflush(stdout);}
+
+  if (FlagValid == 1) read_block_matrix_float(in_valid, Valid, Nb, NbBlock, NligBlock[Nb], Sub_Ncol, NwinL, NwinC, Off_lig, Off_col, Ncol);
+
+  if (strcmp(PolType,"S2")==0) {
+    read_block_S2_noavg(in_datafile, M_in, PolTypeOut, NpolarOut, Nb, NbBlock, NligBlock[Nb], Sub_Ncol, NwinL, NwinC, Off_lig, Off_col, Ncol);
+    } else {
+  /* Case of C,T or I */
+    read_block_TCI_noavg(in_datafile, M_in, NpolarOut, Nb, NbBlock, NligBlock[Nb], Sub_Ncol, NwinL, NwinC, Off_lig, Off_col, Ncol);
+    }
+  if (strcmp(PolTypeOut,"C3")==0) C3_to_T3(M_in, NligBlock[Nb], Sub_Ncol + NwinC, 0, 0);
+
+#pragma omp parallel for private(col, M_avg) firstprivate(Span) shared(ligDone, SpanMin, SpanMax)
+  for (lig = 0; lig < NligBlock[Nb]; lig++) {
+    ligDone++;
+    if (omp_get_thread_num() == 0) PrintfLine(ligDone,NligBlock[Nb]);
+    M_avg = matrix_float(NpolarOut,Sub_Ncol);
+    average_TCI(M_in, Valid, NpolarOut, M_avg, lig, Sub_Ncol, NwinL, NwinC, NwinLM1S2, NwinCM1S2);
+    for (col = 0; col < Sub_Ncol; col++) {
+      if (Valid[NwinLM1S2+lig][NwinCM1S2+col] == 1.) {
+        Span = M_avg[T311][col]+M_avg[T322][col]+M_avg[T333][col];
+        if (Span >= SpanMax) SpanMax = Span;
+        if (Span <= SpanMin) SpanMin = Span;
+        }       
+      }
+    free_matrix_float(M_avg,NpolarOut);
+    }
+  } // NbBlock
+
+  if (SpanMin < eps) SpanMin = eps;
+
+/********************************************************************
+********************************************************************/
+/* DATA PROCESSING */
+for (Np = 0; Np < NpolarIn; Np++) rewind(in_datafile[Np]);
+if (FlagValid == 1) rewind(in_valid);
+
+for (Nb = 0; Nb < NbBlock; Nb++) {
+  ligDone = 0;
+  if (NbBlock > 2) {printf("%f\r", 100. * Nb / (NbBlock - 1));fflush(stdout);}
+ 
+  if (FlagValid == 1) read_block_matrix_float(in_valid, Valid, Nb, NbBlock, NligBlock[Nb], Sub_Ncol, NwinL, NwinC, Off_lig, Off_col, Ncol);
+
+  if (strcmp(PolType,"S2")==0) {
+    read_block_S2_noavg(in_datafile, M_in, PolTypeOut, NpolarOut, Nb, NbBlock, NligBlock[Nb], Sub_Ncol, NwinL, NwinC, Off_lig, Off_col, Ncol);
+    } else {
+  /* Case of C,T or I */
+    read_block_TCI_noavg(in_datafile, M_in, NpolarOut, Nb, NbBlock, NligBlock[Nb], Sub_Ncol, NwinL, NwinC, Off_lig, Off_col, Ncol);
+    }
+  if (strcmp(PolTypeOut,"C3")==0) C3_to_T3(M_in, NligBlock[Nb], Sub_Ncol + NwinC, 0, 0);
+
+tau = theta = 0.;
+Ps = Pd = Pv = Pc = 0.;
+det_re = det_im = trace = trace3 = m1_re = m1_im = m1 = r = 0.;
+k44 = k11 = k14 = s0 = dop = val1 = val2 = res_pow = 0.;
+#pragma omp parallel for private(col, Np, M_avg) firstprivate(theta, tau, Ps, Pd, Pv, Pc, det_re, det_im, trace, trace3, m1_re, m1_im, m1, r, k44, k11, k14, s0, dop, val1, val2, res_pow) shared(ligDone)
+  for (lig = 0; lig < NligBlock[Nb]; lig++) {
+    ligDone++;
+    if (omp_get_thread_num() == 0) PrintfLine(ligDone,NligBlock[Nb]);
+    TT = vector_float(NpolarOut);
+    M_avg = matrix_float(NpolarOut,Sub_Ncol);
+    average_TCI(M_in, Valid, NpolarOut, M_avg, lig, Sub_Ncol, NwinL, NwinC, NwinLM1S2, NwinCM1S2);
+    for (col = 0; col < Sub_Ncol; col++) {
+      if (Valid[NwinLM1S2+lig][NwinCM1S2+col] == 1.) {
+        for (Np = 0; Np < NpolarOut; Np++) TT[Np] = M_avg[Np][col];
+        det_re = - TT[T333] * TT[T312_im] *TT[T312_im]  - 2. * TT[T312_im] * TT[T313_re] * TT[T323_im] + TT[T322] * TT[T313_im] *TT[T313_im]
+                 - TT[T333] * TT[T312_re] * TT[T312_re] + 2. * TT[T312_re] * TT[T313_re] * TT[T323_re] - TT[T322] * TT[T313_re] * TT[T313_re]
+                 - TT[T311] * TT[T323_im] * TT[T323_im] - TT[T311] * TT[T323_re] * TT[T323_re] + TT[T311] * TT[T322] * TT[T333];
+        det_im =  - 2. * (TT[T312_im] * TT[T313_im] * TT[T323_im] - TT[T313_im] * TT[T312_re] * TT[T323_re]  + TT[T322] * TT[T313_im] * TT[T313_re]);
+        trace = TT[T311] + TT[T322] + TT[T333];
+        trace3 = trace * trace * trace;
+        m1_re = 1. - 27. * det_re / trace3;
+        m1_im = 0. - 27. * det_im / trace3;
+        r = sqrt(m1_re * m1_re + m1_im * m1_im);
+        theta = atan2(m1_im, m1_re); /* convert to polar */
+        m1 = sqrt(r) * cos(theta / 2); /* take square root and real part */
+        k44 = (-TT[T311] + TT[T322] + TT[T333]) / 2.;
+        k11 = trace / 2.;
+        k14 = TT[T323_im];
+        s0 = trace;
+        dop = m1;
+        val1 = (4. * dop * k11 * k44) / (k44 * k44 - (1. + 4. * dop + dop) * k11 * k11);
+        val2 = fabs(k14) / k11; /* abs is for ints only! */
+        theta = atan(val1); /* separation for surface and dbl */
+        tau = atan(val2);   /* separation for helix */
+
+        Pc = dop * s0 * (sin(2. * tau));
+        Pv = (1. - dop) * s0;
+        res_pow = s0 - (Pc + Pv);
+        Ps = (res_pow / 2.) * (1. + sin(2. * theta));
+        Pd = (res_pow / 2.) * (1. - sin(2. * theta));
+
+        if (Ps < SpanMin) Ps = SpanMin;
+        if (Pd < SpanMin) Pd = SpanMin;
+        if (Pv < SpanMin) Pv = SpanMin;
+        if (Pc < SpanMin) Pc = SpanMin;
+
+        if (Ps > SpanMax) Ps = SpanMax;
+        if (Pd > SpanMax) Pd = SpanMax;
+        if (Pv > SpanMax) Pv = SpanMax;
+        if (Pc > SpanMax) Pc = SpanMax;
+
+        M_odd[lig][col] = Ps;
+        M_dbl[lig][col] = Pd;
+        M_vol[lig][col] = Pv;
+        M_hlx[lig][col] = Pc;
+        M_theta[lig][col] = theta * 180. / pi;
+        M_tau[lig][col] = tau * 180. / pi;
+
+        } else {
+        M_odd[lig][col] = 0.;
+        M_dbl[lig][col] = 0.;
+        M_vol[lig][col] = 0.;
+        M_hlx[lig][col] = 0.;
+        M_theta[lig][col] = 0.;
+        M_tau[lig][col] = 0.;
+        }
+      }
+    free_matrix_float(M_avg,NpolarOut);
+    free_vector_float(TT);
+    }
+
+  write_block_matrix_float(out_odd, M_odd, NligBlock[Nb], Sub_Ncol, 0, 0, Sub_Ncol);
+  write_block_matrix_float(out_dbl, M_dbl, NligBlock[Nb], Sub_Ncol, 0, 0, Sub_Ncol);
+  write_block_matrix_float(out_vol, M_vol, NligBlock[Nb], Sub_Ncol, 0, 0, Sub_Ncol);
+  write_block_matrix_float(out_hlx, M_hlx, NligBlock[Nb], Sub_Ncol, 0, 0, Sub_Ncol);
+  write_block_matrix_float(out_theta, M_theta, NligBlock[Nb], Sub_Ncol, 0, 0, Sub_Ncol);
+  write_block_matrix_float(out_tau, M_tau, NligBlock[Nb], Sub_Ncol, 0, 0, Sub_Ncol);
+
+  } // NbBlock
+
+/********************************************************************
+********************************************************************/
+/* MATRIX FREE-ALLOCATION */
+/*
+  free_matrix_float(Valid, NligBlock[0]);
+
+  free_matrix3d_float(M_avg, NpolarOut, NligBlock[0]);
+  free_matrix_float(M_odd, NligBlock[0]);
+  free_matrix_float(M_dbl, NligBlock[0]);
+  free_matrix_float(M_vol, NligBlock[0]);
+  free_matrix_float(M_hlx, NligBlock[0]);
+  free_matrix_float(M_theta, NligBlock[0]);
+  free_matrix_float(M_tau, NligBlock[0]);
+*/  
+/********************************************************************
+********************************************************************/
+/* INPUT FILE CLOSING*/
+  for (Np = 0; Np < NpolarIn; Np++) fclose(in_datafile[Np]);
+  if (FlagValid == 1) fclose(in_valid);
+
+/* OUTPUT FILE CLOSING*/
+  fclose(out_odd);
+  fclose(out_dbl);
+  fclose(out_vol);
+  fclose(out_hlx);
+  fclose(out_theta);
+  fclose(out_tau);
+  
+/********************************************************************
+********************************************************************/
+
+  return 1;
+}
diff -urN Soft/src/SVM/grid_polsarpro.c ../polsarpro-6.0.4/Soft/src/SVM/grid_polsarpro.c
--- Soft/src/SVM/grid_polsarpro.c	2024-01-18 16:58:49.924150061 +0100
+++ ../polsarpro-6.0.4/Soft/src/SVM/grid_polsarpro.c	2025-01-08 22:40:18.000000000 +0100
@@ -168,7 +168,7 @@
 //           }
            
 printf("/********************************************************************\n");fflush(stdout);
-printf("PolSARpro v5.0 is free software; you can redistribute it and/or \n");fflush(stdout);
+printf("PolSARpro v6.0.4 is free software; you can redistribute it and/or \n");fflush(stdout);
 printf("modify it under the terms of the GNU General Public License as \n");fflush(stdout);
 printf("published by the Free Software Foundation; either version 2 (1991) of\n");fflush(stdout);
 printf("the License, or any later version. This program is distributed in the\n");fflush(stdout);
diff -urN Soft/src/SVM/svm_classifier.c ../polsarpro-6.0.4/Soft/src/SVM/svm_classifier.c
--- Soft/src/SVM/svm_classifier.c	2024-01-18 16:58:49.924150061 +0100
+++ ../polsarpro-6.0.4/Soft/src/SVM/svm_classifier.c	2025-01-08 22:40:18.000000000 +0100
@@ -1305,7 +1305,7 @@
 	Bmp_flag = 1;
 
 printf("/********************************************************************\n");fflush(stdout);
-printf("PolSARpro v5.0 is free software; you can redistribute it and/or \n");fflush(stdout);
+printf("PolSARpro v6.0.4 is free software; you can redistribute it and/or \n");fflush(stdout);
 printf("modify it under the terms of the GNU General Public License as \n");fflush(stdout);
 printf("published by the Free Software Foundation; either version 2 (1991) of\n");fflush(stdout);
 printf("the License, or any later version. This program is distributed in the\n");fflush(stdout);
diff -urN Soft/src/SVM/svm-predict.c ../polsarpro-6.0.4/Soft/src/SVM/svm-predict.c
--- Soft/src/SVM/svm-predict.c	2024-01-18 16:58:49.924150061 +0100
+++ ../polsarpro-6.0.4/Soft/src/SVM/svm-predict.c	2025-01-08 22:40:18.000000000 +0100
@@ -191,7 +191,7 @@
 	l = 0; count = 0;
 	
 printf("/********************************************************************\n");fflush(stdout);
-printf("PolSARpro v5.0 is free software; you can redistribute it and/or \n");fflush(stdout);
+printf("PolSARpro v6.0.4 is free software; you can redistribute it and/or \n");fflush(stdout);
 printf("modify it under the terms of the GNU General Public License as \n");fflush(stdout);
 printf("published by the Free Software Foundation; either version 2 (1991) of\n");fflush(stdout);
 printf("the License, or any later version. This program is distributed in the\n");fflush(stdout);
